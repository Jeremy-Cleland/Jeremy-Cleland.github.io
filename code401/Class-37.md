# Class 37 Reading Notes | Redux - Combined Reducers

## [Multiple Reducers Example](https://www.youtube.com/watch?v=gBER4Or86hE)

- Q: Why create multiple reducers?

  - A: Creating multiple reducers in Redux can help manage the state of your application more effectively by dividing the
    state into smaller, more focused pieces. This practice is particularly useful for larger applications with complex state structures.

    1. Modularity: Breaking down the state management into smaller, focused reducers allows you to maintain a modular codebase. Each reducer is responsible for managing a specific part of the state, making it easier to understand, debug, and modify.

    1. Separation of concerns: Using multiple reducers helps enforce a clear separation of concerns in your application. By dividing the state into smaller parts, you ensure that each reducer is only concerned with a specific aspect of the state, preventing unnecessary coupling between unrelated parts of the application.

    1. Code maintainability: As your application grows, using multiple reducers can help you maintain a clean and organized codebase. It becomes easier to locate and update the relevant parts of your state management logic when it is separated into individual reducers.

    1. Reusability: By creating smaller, focused reducers, you can potentially reuse them across different parts of your application. This can help you avoid duplicating code and make your codebase more efficient.

    1. Easier testing: With multiple reducers, it's easier to write unit tests for each reducer since they have a smaller and more focused scope. This allows you to test the state management logic independently and ensure that each part of your state is being managed correctly.
- Q: How would you combine multiple reducers?

  - A: To manage multiple reducers in Redux, you can use the combineReducers function, which combines all the individual  reducers into a single, root reducer. This makes it easier to manage your state by delegating the responsibility of handling specific parts of the state to their respective reducers.

- Q: How will you manage state as an immutable object? why?

  - A: In Redux, managing the state as an immutable object is important for maintaining predictability, performance, and easier debugging. Immutable state means that whenever you need to make a change to the state, you create a new state object rather than modifying the existing one.

  Here's how you can manage state as an immutable object in Redux:

  1. Use pure functions: When creating reducers, ensure that they are pure functions. A pure function does not have side effects, and its output depends solely on its inputs. This means that given the same input, a pure function will always produce the same output. When updating the state, a reducer should return a new state object instead of modifying the existing one.

  1. Avoid mutating the state: When you need to update the state in your reducer, avoid using methods that mutate the original object, such as `Array.push()` or `Object.assign()`. Instead, use methods that return new objects or arrays without modifying the original, like `Array.concat()`, `Array.slice()`, and the spread operator (...).

  1.

Utilize libraries: You can use libraries like Immutable.js or Immer to help you manage immutable state more efficiently. These libraries provide a set of data structures and utility functions that ensure your state remains immutable when performing updates.

## [Redux Docs: Using Combined Reducers]()

- Q: `combineReducers` is a utility function to simplify the most common use case when writing ________ .

  - A: Redux reducers.

- Q: Explain how `combineReducers` assembles the new state tree.

  - A: combineReducers is a utility function provided by Redux to help you manage multiple reducers in your application. It takes an object where each key-value pair corresponds to a reducer function responsible for a specific part of the state tree. It then generates a single root reducer function that, when invoked, delegates the state updates to the respective reducer based on the provided action.

  Here's how combineReducers assembles the new state tree:

  1. You create individual reducers that manage specific parts of the state.
  
  1. You pass these reducers as an object to the combineReducers function.

  1. When an action is dispatched to the store, the root reducer generated by combineReducers is invoked with the current state and the action.

  1. The root reducer iterates over all the keys in the state object and delegates the responsibility of updating the state to the respective reducer for each key.

  1. Each reducer updates its own slice of the state based on the action and returns a new state object.
  
  1. The root reducer creates a new state object by assembling the new state tree by combining the updated slices of state returned by the individual reducers.

- Q: How would you define initial state in an app using`combineReducers`?

  - A: Inital state is what was persisted before, such as a local storge or 
## [Redux Docs: Combined Reducer Syntax](https://redux.js.org/usage/structuring-reducers/using-combinereducers/)

- Q: Why will you want to split your reducing functions as your app becomes more complex?

  - A: As your app becoems more complex so does managing the state, by splitting the state with reducing functions it is easier to manage, test, resuse, mantain eparation of concerns and modulatity.

- Q: The _____ helper function turns an object whose values are different reducing functions into a single reducing function you can pass to ____.

  - A: `combineReducers`

- Q: What is a popular convention when naming reducers?

  - A: A popular convention is to name reducers after the state slices they manage, so you can use ES6 property shorthand notation: `combineReducers({ counter, todos })`. This is equivalent to writing `combineReducers({ counter: counter, todos: todos })`.

## Things I want to know more about
